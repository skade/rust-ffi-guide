# Generating Bindings and Writing Wrappers

A lot of the time you'll have a large amount of existing C (or C++, but more of 
that later) code which you need to integrate your Rust tools into, a great 
example of this is [OpenSSL][openssl] or [git][git]. Unless the C code is 
fairly small or trivial it's not going to be feasible to port to Rust, plus
why re-invent the wheel when you could be doing more interesting stuff?

Luckily with Rust you can have your cake and eat it too. As you'll already know
Rust can transparently call C functions as long as you have declarations for
them so the compiler knows what symbols to use. Enter [bindgen][bindgen].

Bindgen does all the hard work of parsing C-style header files and generating 
the equivalent Rust function definitions. They've also got a 
[great tutorial][tut] for getting started so I'm not going to bother 
reiterating the basics. Instead, we'll try to focus on the more high level 
stuff which comes with using a C library from Rust, seeing as the zero cost
abstractions and high level way of approaching things is probably why you're 
trying to do this FFI stuff in the first place!


## Getting Set Up

We'll be building on top of the [great tutorial][tut] I linked earlier to write
an idiomatic Rust wrapper around `bzip2`. I'll assume you've already read
through that tutorial and focus more on the next step, writing the actual
wrapper code and using common Rust patterns.

First we'll create a new crate:

```bash
$ cargo new bzip2
```

Then add `bindgen` as a dependency and tell `Cargo` about our build script
(which doesn't actually exist yet):

```
 name = "bzip2"
 version = "0.1.0"
 authors = ["Michael-F-Bryan <michaelfbryan@gmail.com>"]
+build = "build.rs"
 
 [dependencies]
+
+[build-dependencies]
+bindgen = "0.20.0"
```

`Bindgen` works by reading a `C`-style header file using `libclang`, then
it runs the preprocessor and creates bindings based on the output. Therefore, 
before we can start our build script we'll need a dummy header which pulls in
the `bzip2` library installed on your system.

```c
// wrapper.h
#include <bzlib.h>
```

Now we can create our `build.rs` script. This gets run before the crate is
compiled, and allows us to generate code at compile time.

```Rust
extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rustc-link-lib=bz2");

    let bindings = bindgen::Builder::default()
        .no_unstable_rust()
        .header("wrapper.h")
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
```

Let's compile everything created so far to make sure it actually works.

```bash
$ cargo build 
    Updating registry `https://github.com/rust-lang/crates.io-index`
Downloading bindgen v0.20.5
Downloading syntex_syntax v0.54.0
...
Finished debug [unoptimized + debuginfo] target(s) in 12.41 secs
```

So far, we haven't actually written any code so our `lib.rs` file should still 
just have the auto-generated `it_works()` test. If you want to view the
generated bindings, you'll see that it's not exactly the nicest Rust code to
look at...

```bash
$ find -name "bindings.rs"
./target/debug/build/bzip2-cd18fea72e03763e/out/bindings.rs
```

And here are a couple excerpts from that file:

```Rust
// selected output from ./target/debug/build/bzip2-cd18fea72e03763e/out/bindings.rs

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}

...

pub const BZ_RUN: ::std::os::raw::c_uint = 0;
pub const BZ_FLUSH: ::std::os::raw::c_uint = 1;
pub const BZ_FINISH: ::std::os::raw::c_uint = 2;
pub const BZ_OK: ::std::os::raw::c_uint = 0;
pub const BZ_RUN_OK: ::std::os::raw::c_uint = 1;
pub const BZ_FLUSH_OK: ::std::os::raw::c_uint = 2;

...

#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub next_in: *mut ::std::os::raw::c_char,
    pub avail_in: ::std::os::raw::c_uint,
    pub total_in_lo32: ::std::os::raw::c_uint,
    pub total_in_hi32: ::std::os::raw::c_uint,
    pub next_out: *mut ::std::os::raw::c_char,
    pub avail_out: ::std::os::raw::c_uint,
    pub total_out_lo32: ::std::os::raw::c_uint,
    ...
}
pub type bz_stream = _bindgen_ty_1;
```

I usually like to put my FFI bindings in their own sub-module, we can now
replace the contents of `lib.rs` and recompile.

```Rust
pub mod ffi {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]

    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}
```

> **Note:** You'll notice I made the `ffi` module public. I've done this during
> the development stage so we can easily view the FFI bindings using 
> `cargo doc --open`. We'll make it private later on so users are forced to go
> through our Rust-ic API.


## Creating The Rust Wrapper

Now that we've got a basic crate and know our build system works (i.e.
`bindgen` is creating our bindings, and we can get started on wrapping the
`bzip2` library and giving it a safe API.

The best way to figure out how our wrapper API should look is to find existing
code and (roughly) copy that. Luckily `libbzip2` documents its low level
interface [on their website][libbzip2] and they explain how each of the
functions work. According to the docs, this is roughly how you'd compress some
data:

> That still looks complicated? Well, fair enough. The usual sequence of 
> calls for compressing a load of data is:
>
> 1. Get started with `BZ2_bzCompressInit()`.
> 
> Shovel data in and shlurp out its compressed form using zero or more calls 
> of `BZ2_bzCompress()` with action = `BZ_RUN`.
>
> Finish up. Repeatedly call `BZ2_bzCompress()` with action = `BZ_FINISH`, 
> copying out the compressed output, until `BZ_STREAM_END` is returned.
>
> Close up and go home. Call `BZ2_bzCompressEnd()`.

From this, my thinking is that you'll want some `Compressor` object which
contains the `bz_stream`. We'll run `BZ2_bzCompressInit()` in the constructor
and write a `Drop` impl which calls `BZ2_bzCompressEnd()`. To make things
simple this won't be a streaming compressor so we'll just compress everything
from an input `Read`-er and write it to a `Write`-r. I wouldn't recommend
trying to compress gigabyte-sized files, but it should work well enough.

Error handling should be fairly easy, all `libbzip2` functions return an
integer which corresponds to a error code, this should be fairly trivial to map 
to a Rust enum and we'll add a `std::convert::From<i32>` impl for convenience 
(so you can call `error_code.into()` to automatically get the error enum).

Technically the `BZ2_bzCompressEnd()` destructor could fail if we pass in an
invalid stream, but if that's the case then the worst that happens is we leak
memory. I'll just ignore errors in the `Drop` impl for now.

First for the `Compressor` definition:

```Rust
pub struct Compressor {
    stream: Box<ffi::bz_stream>,
}
```

Next we'll write a `new()` method which creates a zeroed `bz_stream` and then
initializes it with the `BZ2_bzCompressInit()` function. You'll notice that
any return code other than `ffi::BZ_OK` is cast to i32 and converted to a 
`Bzip2Error`.

```Rust
impl Compressor {
    pub fn new() -> Result<Compressor, Bzip2Error> {
        unsafe {
            let mut comp = Compressor { stream: Box::new(mem::zeroed()) };
            let result = ffi::BZ2_bzCompressInit(&mut *comp.stream,
                                                 1, // 1 x 100000 block size
                                                 0, // verbosity (4 = most verbose)
                                                 0); // default work factor
            match result as u32 {
                ffi::BZ_OK => Ok(comp),
                other => Err((other as i32).into()),
            }
        }
    }
```

The `compress()` method is a bit more complicated, in it we have to:

* Read all the input into a buffer
* Create an output buffer of similar length
* Set the corresponding properties on the `self.stream` struct so that
    `libbzip2` knows where the buffers are and their sizes
* Call the `ffi::BZ2_bzCompress()` function
* Deal with the result by either:
    * Writing the compressed output to the destination, or
    * Returning the correct error

```Rust
    pub fn compress<R: Read, W: Write>(&mut self,
                                       mut src: R,
                                       mut dest: W)
                                       -> Result<(), Bzip2Error> {
        let mut input = vec![];
        src.read_to_end(&mut input)?;
        let mut compressed_output = vec![0; input.len()];

        self.stream.next_in = input.as_ptr() as *mut _;
        self.stream.avail_in = input.len() as _;
        self.stream.next_out = compressed_output.as_mut_ptr() as *mut _;
        self.stream.avail_out = compressed_output.len() as _;

        unsafe {
            let result = ffi::BZ2_bzCompress(&mut *self.stream, ffi::BZ_FINISH as _);
            match result as u32 {
                ffi::BZ_FINISH_OK |
                ffi::BZ_RUN_OK |
                ffi::BZ_FLUSH_OK |
                ffi::BZ_STREAM_END => {
                    dest.write_all(&mut compressed_output)
                        .map(|_| ())
                        .map_err(|e| e.into())
                }
                other => Err((other as i32).into()),
            }
        }
    }
}
```

> **Note:** This function definitely violates the *Single Responsibility
> Principle* and should be refactored out into several functions, but for the
> sake of this example I won't worry about it.

Finally we need to write a `Drop` implementation to make sure everything is
cleaned up correctly afterwards. This one is really simple.

```Rust
impl Drop for Compressor {
    fn drop(&mut self) {
        unsafe {
            ffi::BZ2_bzCompressEnd(&mut *self.stream);
        }
    }
}
```

> **Exercise for the reader:** Try to figure out a way to handle errors in the
> destructor. What would happen when there's a panic further down the stack and 
> this `drop()` fails when it's unrolling?

To handle errors, I just made a simple enum which corresponds to either a
`libbzip2` error constant or an `io::Error`. 

```Rust
#[derive(Debug)]
pub enum Bzip2Error {
    Config,
    Params,
    Memory,
    InvalidSequence,
    Io(Box<io::Error>),
}

impl From<i32> for Bzip2Error {
    fn from(val: i32) -> Bzip2Error {
        match val {
            ffi::BZ_CONFIG_ERROR => Bzip2Error::Config,
            ffi::BZ_PARAM_ERROR => Bzip2Error::Params,
            ffi::BZ_MEM_ERROR => Bzip2Error::Memory,
            ffi::BZ_SEQUENCE_ERROR => Bzip2Error::InvalidSequence,
            unknown => panic!("Invalid error code: {}", unknown),
        }
    }
}

impl From<io::Error> for Bzip2Error {
    fn from(val: io::Error) -> Bzip2Error {
        Bzip2Error::Io(Box::new(val))
    }
}
```


[openssl]: https://github.com/sfackler/rust-openssl
[git]: https://github.com/alexcrichton/git2-rs
[bindgen]: https://github.com/servo/rust-bindgen
[tut]: http://fitzgeraldnick.com/2016/12/14/using-libbindgen-in-build-rs.html
[libtcod]: https://bitbucket.org/libtcod/libtcod
[git-hg]: https://github.com/cosmin/git-hg
[ubuntu-instructions]: https://bitbucket.org/libtcod/libtcod/src/f3486b0851a2acf11efbd2df18fc06501012afef/README-linux-SDL2.md?fileviewer=file-view-default
[libbzip2]: http://www.bzip.org/1.0.5/bzip2-manual-1.0.5.html#libprog
